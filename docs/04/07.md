Вы уже научились присоединять таблицы и назначать псевдонимы, но чтобы не совершать ошибок, нужно знать порядок выполнения операторов.

Вы написали уже много запросов и знаете, какой оператор указывать в начале, а какой — в конце. Повторим основные правила:

*   Запрос обычно начинают с `SELECT`, затем пишут `FROM`, а за ними следуют разные `WHERE` и `GROUP BY`.
*   Некоторые операторы пишут в самом конце запроса, например `ORDER BY` и `LIMIT`. Если есть оба оператора — `LIMIT` нужно указать последним.
*   Оператор `HAVING` всегда указывают после `GROUP BY`, но никогда перед ним.

Эти правила вам должны быть знакомы, но порядок выполнения операторов может быть совсем другим.

Операторы действуют в таком порядке:

1.  Сначала нужно определить, откуда брать данные, поэтому первым идёт оператор `FROM`. На этом же этапе объединяются таблицы и назначаются для них псевдонимы. Важно учесть, что присоединение предшествует фильтрации и группировке. Это означает, что большие таблицы будут объединяться очень долго. Как решить такую проблему, вы узнаете в следующей теме.
2.  Данные выбраны, и наступает очередь оператора `WHERE`. Остаются только те данные, которые соответствуют условиям.
3.  После срезов выполняется группировка оператором `GROUP BY` и подсчёт данных агрегирующими функциями. Обратите внимание, что `WHERE` предшествует `GROUP BY`, и это не позволяет сделать срез по группам. В момент получения среза группировка ещё не произошла.
4.  Теперь наступает очередь `HAVING` — отбираются уже сгруппированные данные.
5.  Только на этом этапе происходит выбор данных с помощью оператора `SELECT`, а полям в итоговой таблице присваиваются псевдонимы. По этой причине псевдонимы нельзя использовать после `WHERE` и `HAVING` — они ещё не назначены. В некоторых СУБД псевдонимы нельзя использовать и после `GROUP BY`. В PostgreSQL есть расширение, которое устраняет эту проблему.
6.  После `SELECT` срабатывает ключевое слово `DISTINCT`, которое отбирает уникальные значения.
7.  Нужные данные отобраны, и происходит сортировка. Оператор `ORDER BY` действует предпоследним.
8.  Замыкающим будет оператор `LIMIT`.

* * *

Выберите правильную последовательность, в которой будут выполнены операторы:

*   `SELECT`, `GROUP BY,` `HAVING`, `ORDER BY`
    
*   `HAVING`, `GROUP BY`, `SELECT`, `ORDER BY`
    
*   `GROUP BY`, `HAVING`, `SELECT`, `ORDER BY`
    
*   `ORDER BY`, `GROUP BY`, `HAVING`, `SELECT`
    

* * *

Выберите запрос, который написан с ошибкой.

*       SELECT customer_id AS customer ,
           billing_city AS city,
             total AS total_revenue
        FROM invoice
        WHERE total_revenue > 20
        
    
*       SELECT il.unit_price,
           i.billing_address
        FROM invoice_line AS il JOIN invoice AS i ON il.invoice_id = i.invoice_id
        WHERE il.unit_price > 0.99
        ORDER BY i.billing_address
        
    
*       SELECT g.name AS genre_name,
           COUNT(g.name) AS all_genre
        FROM track AS t JOIN genre AS g ON t.genre_id = g.genre_id
        GROUP BY genre_name
        HAVING all_genre > 20

Ответы на задания
-----------------

* * *

Выберите правильную последовательность, в которой будут выполнены операторы:

*   **(-)** `SELECT`, `GROUP BY,` `HAVING`, `ORDER BY`
    
    *   В таком порядке операторы указывают в запросе. Но порядок выполнения будет другим.
*   **(-)** `HAVING`, `GROUP BY`, `SELECT`, `ORDER BY`
    
    *   `HAVING` не может предшествовать `GROUP BY`, его используют после группировки.
*   **(+)** `GROUP BY`, `HAVING`, `SELECT`, `ORDER BY`
    
    *   Может показаться странным, что `SELECT` не на первом месте. Но вид итоговой таблицы формируется после группировки и фильтрации.
*   **(-)** `ORDER BY`, `GROUP BY`, `HAVING`, `SELECT`
    
    *   `ORDER BY` сортирует уже полностью сформированные данные, поэтому не может выполняться первым.

* * *

Выберите запрос, который написан с ошибкой.

*   **(+)** `sql SELECT customer_id AS customer , billing_city AS city, total AS total_revenue FROM invoice WHERE total_revenue > 20`
    
    *   `total_revenue` — псевдоним, который назначается уже после среза. Его нельзя использовать в `WHERE`.
*   **(-)** `sql SELECT il.unit_price, i.billing_address FROM invoice_line AS il JOIN invoice AS i ON il.invoice_id = i.invoice_id WHERE il.unit_price > 0.99 ORDER BY i.billing_address`
    
    *   В этом запросе нет ошибки.
*   **(+)** `sql SELECT g.name AS genre_name, COUNT(g.name) AS all_genre FROM track AS t JOIN genre AS g ON t.genre_id = g.genre_id GROUP BY genre_name HAVING all_genre > 20`
    
    *   Псевдонимы нельзя использовать и после `HAVING`, ведь они ещё не назначены.