С помощью объединения таблиц можно решать разные задачи, порой и необычные. В базе онлайн-магазина хранятся две таблицы: `actor` и `client`. Таблица `actor` включает в себя данные обо всех актёрах и актрисах, снимавшихся в фильмах, которые можно арендовать в онлайн-магазине. Уже известная вам таблица `client` содержит информацию о пользователях, которые покупают фильмы или музыку. Кажется, у этих двух таблиц мало пересечений, но их тоже можно объединить.

Каждого пользователя в день рождения поздравляют особенным письмом. А если пользователь является однофамильцем известного актёра или актрисы, таким пользователям можно присылать дополнительную рассылку. Можно объединить таблицы, чтобы составить такую рассылку.

Дело за малым — подготовить таблицу, в которой будут указаны пользователи вместе со своими известными однофамильцами. При этом в таблицу должны войти даже те актёры и актрисы, у которых нет однофамильцев среди пользователей, — их даты рождения пригодятся для других тематических рассылок.

Но есть проблема: между таблицами `actor` и `client` нет прямой связи. В обеих таблицах указаны фамилии, но они никак не связаны со структурой базы данных. Это нестрашно. В PostgreSQL можно объединять таблицы не только по ключам: первичным и внешним. Если в таблицах можно найти поля с одинаковыми названиями и похожим содержанием, объединить таблицы можно с помощью таких полей.

Все имена и фамилии из обеих таблиц должны попасть в базу, поэтому для такой задачи подойдёт оператор `FULL OUTER JOIN`. Его используют, чтобы вывести все записи из левой и правой таблиц.

Таблица должна содержать поля `actor_id`, `first_name`, `last_name` для актёра или актрисы, а также `first_name` и `last_name` для пользователя.

    SELECT a.actor_id,
           a.first_name,
           a.last_name,
           c.first_name,
           c.last_name
    FROM actor AS a
    FULL OUTER JOIN client AS c ON a.last_name = c.last_name
    LIMIT 10;
    

| actor\_id | first\_name | last\_name | first\_nаme | last\_nаme |
| --- | --- | --- | --- | --- |
| 1 | Penelope | Guiness | \[null\] | \[null\] |
| 2 | Nick | Wahlberg | \[null\] | \[null\] |
| 3 | Ed | Chase | Kathy | Chase |
| 4 | Jennifer | Davis | \[null\] | \[null\] |
| 5 | Johny | Lollobrigida | \[null\] | \[null\] |
| 6 | Bette | Nicholson | \[null\] | \[null\] |
| 7 | Grace | Mostel | \[null\] | \[null\] |
| 8 | Matthew | Johansson | Joakim | Johansson |
| 9 | Joe | Swank | \[null\] | \[null\] |
| 10 | Christian | Gable | \[null\] | \[null\] |

Уже в первых десяти строках целых два совпадения. Для всех актёров и актрис, для которых не нашлось однофамильцев, значения в имени и фамилии пользователя преобразовались в `NULL`.

Стоит обратить внимание на то, что `FULL OUTER JOIN` не самый популярный оператор. Старайтесь использовать его только на небольших таблицах. Крупные таблицы при использовании `FULL OUTER JOIN` могут увеличиться ещё больше, а это усложнит работу с данными.